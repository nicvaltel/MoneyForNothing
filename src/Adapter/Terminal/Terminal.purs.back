module Adapter.Terminal.Terminal where

import GameClass
import Logic.Types
import Prelude

import Control.Monad.Reader (class MonadAsk, class MonadReader, ReaderT, ask, runReaderT)
import Effect (Effect)
import Effect.Class (class MonadEffect, liftEffect)
import Effect.Console (log)
import Effect.Ref (Ref, read, write)
import Node.ReadLine as ReadLine
import Utils.Utils (undefined)





type TerminalData = 
  { interface :: ReadLine.Interface
  , writeRef :: Ref String
  }

data Terminal a = Terminal (ReaderT TerminalData Effect a)

unTerminal :: forall a. Terminal a -> ReaderT TerminalData Effect a
unTerminal (Terminal readerT) = readerT

instance functorTerminal :: Functor Terminal where
  map f (Terminal x) = Terminal (map f x)

instance applyTerminal :: Apply Terminal where
  -- apply (Terminal f) (Terminal x) = Terminal (apply f x)
  apply = ap

instance applicativeTerminal :: Applicative Terminal where
  pure x = Terminal (pure x)

instance bindTerminal :: Bind Terminal where
  bind (Terminal rT) k = Terminal $ do
    x <- rT
    unTerminal (k x)

instance monadTerminal :: Monad Terminal

instance monadEffectTerminal :: MonadEffect Terminal where
  liftEffect = Terminal <<< liftEffect
  -- liftEffect = unsafeCoerce

instance monadAskTerminal :: MonadAsk TerminalData Terminal where
  ask = Terminal ask

instance monadReaderTerminal :: MonadReader TerminalData Terminal where
  local f (Terminal rT) = Terminal $ do
    e <- ask
    x <- rT
    runReaderT (pure x) (f e)
  
  
instance gameIOTerminal :: GameIO Terminal where
  showState :: GameState -> Terminal Unit
  showState gs = liftEffect $ log $ show gs

  displayMessage :: String -> Terminal Unit
  displayMessage str = liftEffect $ log str

  getUserInput :: Terminal UserInput
  getUserInput = do
    td <- ask
    str <- liftEffect $ do
      ReadLine.prompt td.interface
      td.interface # ReadLine.question "?" \s ->
        case s of
          "quit" -> ReadLine.close td.interface
          _ -> do
            log $ "You typed: " <> s
            write s td.writeRef
      -- td.interface # ReadLine.setLineHandler \s -> write s td.writeRef
      read td.writeRef
    pure (UserInput str)




------------ EXAMPLE ---------------

-- gameLoop :: GameState -> Terminal Unit
-- gameLoop gs = do
--     showState gs
--     (UserInput input) <- getUserInput
--     liftEffect $ log input
--     newGs <- liftEffect $ processRollDice gs
--     gameLoop newGs
--     -- pure unit

-- runGameLoop :: Effect Unit
-- runGameLoop = do
--   writeRef <- new ""
--   interface <- ReadLine.createConsoleInterface ReadLine.noCompletion
--   ReadLine.setPrompt "> " interface

--   x <- do
--       ReadLine.prompt interface
--       interface # ReadLine.question "?" \s ->
--         case s of
--           "quit" -> ReadLine.close interface
--           _ -> do
--             log $ "You typed: " <> s
--             write s writeRef
--       read writeRef
--   log x
  